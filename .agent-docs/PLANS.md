# Codex 执行计划（ExecPlan）

本文档说明了执行计划（“ExecPlan”）的要求。ExecPlan 是一种设计文档，编码代理可以依据它交付可工作的功能或系统变更。请把读者视为这个仓库的完全新手：他们只有当前工作树和你提供的这一个 ExecPlan 文件。他们不记得任何历史计划，也没有外部上下文。

## 如何使用 ExecPlan 和 PLANS.md

在编写可执行规范（ExecPlan）时，必须**严格逐条遵守** PLANS.md。若它不在你的上下文中，请重新通读整个 PLANS.md 来刷新记忆。为了产出准确规范，要彻底阅读（并反复阅读）源材料。创建规范时，从骨架开始，并在调研过程中逐步补全细节。

在实现可执行规范（ExecPlan）时，不要向用户询问“下一步是什么”；应直接推进到下一个里程碑。保持所有章节为最新状态，在每个暂停点都要新增或拆分进度条目，明确说明已完成进展和后续步骤。遇到歧义时自主决策，并频繁提交。

在讨论可执行规范（ExecPlan）时，要在规范中记录决策日志以便追溯；任何对规范的修改原因都必须清晰明确。ExecPlan 是活文档，应始终可以仅凭 ExecPlan（不依赖其他工作）重启推进。

当设计调研存在高难要求或大量未知时，使用里程碑实现概念验证、玩具实现等，以验证用户提案是否可行。通过查找或获取库源码进行深入研究，并纳入原型来指导完整实现。

## 要求

不可协商的要求：

* 每个 ExecPlan 都必须完全自包含。所谓自包含，是指其当前形态包含新手成功所需的全部知识和指令。
* 每个 ExecPlan 都是活文档。贡献者必须随着进展、发现和设计定稿持续修订。每次修订后仍须保持完全自包含。
* 每个 ExecPlan 都必须让完全新手在不了解仓库背景的情况下端到端实现功能。
* 每个 ExecPlan 都必须产出可被证明“真的可工作”的行为，而不仅仅是“满足定义”的代码改动。
* 每个 ExecPlan 都必须用通俗语言定义所有术语；做不到就不要使用术语。

目的和意图优先。开头先用几句话解释这项工作为何重要（从用户视角）：变更后用户能做到什么此前做不到的事，以及如何看到它确实在工作。然后逐步引导读者达成该结果，包含要改哪些内容、要运行什么命令、应观察到什么现象。

执行你计划的代理可以列出文件、读取文件、搜索、运行项目、运行测试。它不知道任何先验背景，也无法从早前里程碑推断你的意图。你依赖的所有假设都要重复说明。不要指向外部博客或文档；若需要知识，就用你自己的话嵌入计划中。若 ExecPlan 基于先前 ExecPlan 且该文件已提交到仓库，可通过引用方式纳入；若未提交，则必须在当前计划中补全所有相关上下文。

## 格式

格式与包裹规则简单且严格。每个 ExecPlan 必须是**单个**标记为 `md` 的 fenced code block，且以三反引号开始和结束。不要在内部再嵌套三反引号代码块；需要展示命令、终端记录、diff 或代码时，请在该单一代码块中使用缩进块。为避免提前闭合 ExecPlan 的代码围栏，应使用缩进提升可读性，而不是在 ExecPlan 内再套代码围栏。每个标题后使用两个换行，标题层级用 `#`、`##` 等标准语法，有序/无序列表都要使用正确 Markdown 语法。

当你把 ExecPlan 写入一个 Markdown（`.md`）文件，且该文件内容**仅有**这一个 ExecPlan 时，应省略三反引号。

使用平实叙述。优先句子而非列表。除非为了简洁必须如此，否则避免清单、表格、长枚举。仅 `Progress` 章节允许（且要求）使用勾选清单。叙事性章节必须以 prose 为主。

## 指南

自包含和通俗语言是首要原则。若你引入非日常英语词汇（如 “daemon”“middleware”“RPC gateway”“filter graph”），要立刻定义，并说明它在本仓库中的体现（例如指出出现的文件或命令）。不要写“如前所述”或“根据架构文档”。即使会重复，也要在这里写出必要解释。

避免常见失败模式。不要依赖未定义术语。不要把功能描述得过于“字面”而导致代码虽可编译却无实质意义。不要把关键决策外包给读者。存在歧义时，应在计划中直接裁决并解释理由。宁可多解释用户可感知效果，也不要过度规定偶然实现细节。

用可观测结果锚定计划。说明实现后用户能做什么、要运行什么命令、应看到什么输出。验收应表述为人类可验证的行为（例如“启动服务后访问 [http://localhost:8080/health](http://localhost:8080/health) 返回 HTTP 200，响应体为 OK”），而非内部属性（例如“新增了 HealthCheck 结构体”）。若改动是内部性的，也要解释如何证明其影响（例如运行“改前失败、改后通过”的测试，并展示使用新行为的场景）。

明确仓库上下文。用仓库相对路径写清文件名，精确写出函数和模块名，并描述新文件应创建在何处。若涉及多个区域，先写一段简短导读，说明这些部分如何关联，便于新手导航。执行命令时写明工作目录和完整命令行。若结果依赖环境，要说明假设，并在合理情况下提供替代方案。

保证幂等与安全。步骤应可重复执行且不造成破坏或漂移。若步骤可能中途失败，要给出重试或调整方式。若必须执行迁移或破坏性操作，要明确备份或安全回退路径。优先可增量验证的可测试改动。

验证不是可选项。必须包含测试运行说明；如适用，还要包含系统启动与功能观察说明。任何新功能/能力都要给出完整测试方法。提供期望输出和错误信息，让新手能判断成败。尽可能证明变更不仅能编译（例如给出一个端到端场景、CLI 调用、或 HTTP 请求/响应记录）。写明项目工具链对应的准确测试命令，以及如何解读结果。

保留证据。步骤若产生终端输出、简短 diff 或日志，请在同一个 fenced block 内用缩进示例给出。保持简洁，只保留能证明成功的关键信息。若需要展示补丁，优先给出按文件范围的 diff 或可复现的小片段，不要粘贴大块内容。

## 里程碑

里程碑是叙事工具，不是官僚流程。若把工作拆成里程碑，每个里程碑都要先用一段话说明范围、完成后新增了什么、需运行哪些命令、预期看到哪些验收结果。保持故事性可读：目标、工作、结果、证据。进度与里程碑是两个维度：里程碑讲故事，进度跟踪细颗粒工作。二者必须同时存在。不要为了简短而压缩里程碑，不要省略任何可能影响未来实现的关键细节。

每个里程碑都必须可独立验证，并且是对整体目标的增量实现。

## 活计划与设计决策

* ExecPlan 是活文档。每当做出关键设计决策，都要更新计划，记录“决策本身”和“背后思考”。所有决策都记录在 `Decision Log` 章节。
* ExecPlan 必须包含并维护 `Progress`、`Surprises & Discoveries`、`Decision Log`、`Outcomes & Retrospective` 四个章节。这些章节是必需项。
* 当你发现了优化器行为、性能权衡、意外 bug，或影响方案的逆操作/回滚语义时，要在 `Surprises & Discoveries` 中记录并附简短证据片段（理想是测试输出）。
* 若实现中途改道，要在 `Decision Log` 说明原因，并在 `Progress` 反映影响。计划既是给你自己的清单，也是给下一位贡献者的指南。
* 完成一个大任务或整个计划时，在 `Outcomes & Retrospective` 写总结：已完成什么、剩余什么、经验教训是什么。

# 原型里程碑与并行实现

在大型变更中，为降低风险而加入明确的原型里程碑是可接受的，而且通常值得鼓励。示例：给依赖新增底层操作符以验证可行性，或探索两种组合顺序并测量优化效果。原型应保持可增量、可测试。明确标注范围为“原型验证”；说明如何运行和观察结果；并给出“升级为正式实现”或“废弃原型”的判定标准。

优先采用“先增量添加，再减量移除且保持测试通过”的策略。并行实现（例如迁移期间保留适配层与旧路径并存）在降低风险或保持测试持续通过时是合理的。需描述如何验证两条路径，以及如何借助测试安全下线其中一条。当同时引入多个新库或多个功能域时，可考虑创建 spike（探索分支）来分别验证它们的可行性，独立证明外部库表现符合预期，并能在隔离条件下实现所需能力。

## 优秀 ExecPlan 骨架

    # <简短、面向行动的描述>

    本 ExecPlan 是活文档。`Progress`、`Surprises & Discoveries`、`Decision Log`、`Outcomes & Retrospective` 四个章节必须随着工作推进持续更新。

    如果仓库中已提交 PLANS.md，请在此处写明其仓库根路径，并注明本文件必须按 PLANS.md 维护。

    ## Purpose / Big Picture

    用几句话说明变更后用户获得了什么，以及如何看到它工作。明确你要启用的用户可见行为。

    ## Progress

    使用带复选框的列表总结细颗粒步骤。每个暂停点都必须记录在此，即使需要把部分完成的任务拆成两个条目（“已完成”与“剩余”）。本节必须始终反映工作真实现状。

    - [x] (2025-10-01 13:00Z) 示例：已完成步骤。
    - [ ] 示例：未完成步骤。
    - [ ] 示例：部分完成步骤（已完成：X；剩余：Y）。

    使用时间戳衡量推进速度。

    ## Surprises & Discoveries

    记录实现过程中发现的意外行为、缺陷、优化或洞见，并附简明证据。

    - Observation: …
      Evidence: …

    ## Decision Log

    按以下格式记录实施期间的每一项决策：

    - Decision: …
      Rationale: …
      Date/Author: …

    ## Outcomes & Retrospective

    在重要里程碑或全部完成时，总结产出、缺口与经验，并对照最初目标评估结果。

    ## Context and Orientation

    按“读者一无所知”来描述与任务相关的当前状态。用完整路径点名关键文件和模块。定义任何非显然术语。不要引用以往计划。

    ## Plan of Work

    用 prose 描述编辑与新增的顺序。对每项修改，写明文件与位置（函数、模块）以及要插入或变更的内容。保持具体且最小化。

    ## Concrete Steps

    写明准确命令及其执行目录（working directory）。命令若会产生输出，给出简短期望终端片段供读者比对。本节必须随推进持续更新。

    ## Validation and Acceptance

    说明如何启动或操作系统，以及应观察到什么。验收要表述为行为，并给出明确输入与输出。若涉及测试，写成“运行 <项目测试命令>，预期 <N> 个通过；新增测试 <name> 在改动前失败、改动后通过”。

    ## Idempotence and Recovery

    若步骤可安全重复，明确写出。若步骤有风险，给出安全重试或回滚路径。完成后保持环境整洁。

    ## Artifacts and Notes

    用缩进示例收录最重要的终端记录、diff 或片段。保持简洁，只保留能证明成功的内容。

    ## Interfaces and Dependencies

    要有明确约束。点名要使用哪些库、模块、服务，以及原因。指明在里程碑结束时必须存在的类型、trait/interface、函数签名。优先稳定命名与路径，如 `crate::module::function` 或 `package.submodule.Interface`。例如：

    在 `crates/foo/planner.rs` 中定义：

        pub trait Planner {
            fn plan(&self, observed: &Observed) -> Vec<Action>;
        }

若你遵循上述指导，单个无状态代理或人类新手都可以从头到尾阅读 ExecPlan，并产出可工作、可观测的结果。这就是标准：**自包含、自给自足、面向新手、结果导向**。

当你修订计划时，必须确保变更被完整反映到所有章节（含活文档章节），并且要在计划底部写一条说明，注明改了什么以及为什么改。ExecPlan 不仅要描述“做什么”，也要解释几乎所有关键点背后的“为什么”。
